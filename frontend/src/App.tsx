import * as React from "react";
import "katex/dist/katex.min.css";
import { InlineMath, BlockMath } from "react-katex";
import { Cat, Dog } from "./Util";
import { ThemeProvider } from "styled-components";
import {
  typography,
  color,
  ColorProps,
  space,
  SpaceProps,
  TypographyProps,
  LayoutProps,
  layout,
  FlexboxProps,
  flexbox
} from "styled-system";

import ReactFullpage from "@fullpage/react-fullpage";

import styled from "styled-components";
import theme from "./theme";
import { Landing } from "./Landing";

type BoxProps = TypographyProps &
  ColorProps &
  SpaceProps &
  LayoutProps &
  FlexboxProps;

const Box = styled.div<BoxProps>`
  ${typography}
  ${color}
  ${space}
  ${layout}
  ${flexbox}
`;

const P = styled.p<TypographyProps & ColorProps & SpaceProps>`
  ${typography}
  ${color}
  ${space}
`;

const Page = styled.div<TypographyProps & ColorProps & SpaceProps>`
  ${typography}
  ${color}
  ${space}
`;

const ascii = "\\int_0^\\infty x^2 dx";
const Definition = () => (
  <P color="primary">
    Here is some math <InlineMath math={ascii} /> and it's inline. Here is some
    block math:
    <BlockMath math={ascii}></BlockMath>
  </P>
);

const Story = () => (
  <Box
    fontSize={4}
    fontFamily="story"
    fontWeight="bold"
    p={3}
    mb={[4, 5]}
    color="white"
    bg="primary"
    width={1 / 2}
    m="auto"
  >
    A <Cat /> wants to go to a <Dog />
    -only Halloween party, so she went to the sorceress for help. The sorceress
    specializes in magically generating
    <Dog />
    -looking cats. The key to getting into the party is to pass the <Dog />
    -ness inspection by another powerful sorceress, so the disguise has to be
    indistinguishable from other <Dog /> guests.
  </Box>
);

const Concept = () => (
  <P fontFamily="body" p={3}>
    Generative Adversarial Networks comprise of two models:
    <li>
      The first model is the Generator (Gina) and it aims to generate new data
      similar to the expected one. The Generator could be assimilated to a human
      art forger, which creates fake works of art.
    </li>
    <li>
      The second model is the Discriminator (Dorothy). This model’s goal is to
      recognize if an input data is ‘real’ — belongs to the original dataset —
      or if it is ‘fake’ — generated by a forger. In this scenario, a
      Discriminator is analogous to the police (or an art expert), which tries
      to detect artworks as truthful or fraud.
    </li>
  </P>
);

const Math = () => (
  <P>
    <li>
      Nash equilibrium: “GAN is based on the zero-sum non-cooperative game. In
      short, if one wins the other loses. A zero-sum game is also called
      minimax. Your opponent wants to maximize its actions and your actions are
      to minimize them. In game theory, the GAN model converges when the
      discriminator and the generator reach a Nash equilibrium. This is the
      optimal point for the minimax equation below.”
    </li>
    <li>
      The problem of convergence and different measures of divergence, along
      with the fact that real GANs are <em>not</em> optimizing towards NE, but
      rather approximating and minimizing (some measure of) divergence.
    </li>
  </P>
);

const FullPage = () => (
  <ReactFullpage
    //fullpage options
    licenseKey={"YOUR_KEY_HERE"}
    scrollingSpeed={1000} /* Options here */
    render={() => {
      return (
        <ReactFullpage.Wrapper>
          <ThemeProvider theme={theme}>
            <Landing></Landing>
            <Page bg="background" className="section">
              <Story />
            </Page>
            <Page bg="background" className="section">
              <Concept />
            </Page>
            <Page bg="background" className="section">
              <Definition />
              <Math />
            </Page>
            {/* <BarChart
            data={data}
            width={400}
            height={400}
            margin={{ top: 10, bottom: 50, left: 50, right: 10 }}
          /> */}
          </ThemeProvider>
        </ReactFullpage.Wrapper>
      );
    }}
  />
);

class App extends React.Component {
  public render() {
    return (
      <>
        <FullPage />;
      </>
    );
  }
}

export default App;
